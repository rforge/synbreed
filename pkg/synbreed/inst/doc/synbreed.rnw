%\VignetteIndexEntry{Getting started with the package}
%\VignetteKeywords{getting started}
%\VignettePackage{synbreed}

\documentclass[a4paper,11pt]{article}
\usepackage{natbib}
\bibliographystyle{apalike}

% Preabmle parts
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{times}

%PSTricks
\usepackage{pdftricks}
\begin{psinputs}
  \usepackage{pst-all}
\end{psinputs}

\usepackage{bm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{verbatim}
\usepackage{epsfig}
\usepackage{comment}
\usepackage{pdfpages}
\usepackage{algorithm2e}

\usepackage{Sweave}
\usepackage{fancyvrb}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom={\color{Sinput}},fontsize=\small,fontshape=sl}
\definecolor{Soutput}{rgb}{0,0,0.56}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{formatcom={\color{Soutput}},fontsize=\small,fontshape=sl}


\title{The R-Package 'synbreed'}
\author{
Valentin Wimmer\thanks{Author of correspondance. Contact: Institute for plant breeding, Technical University of Munich, Emil-Ramann-Str. 4,
	85354 Freising, Germany, Email: \texttt{Valentin.Wimmer@wzw.tum.de}}\\
} \date{\today}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sweave
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Put all in another directory
\SweaveOpts{prefix.string=figs/vignette}
 \setkeys{Gin}{width=0.9\textwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initial R code
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


<<echo=F,results=hide>>=
library(surveillance)
options(SweaveHooks=list(fig=function() par(mar=c(5,4,4,0),cex.axis=1,cex.lab=1,cex.main=1)))
options(width=70)
set.seed(1234)
@


\maketitle


\begin{abstract}
  \noindent This document gives an introduction to the R-package
  'synbreed' which contains tools and methods for plant and animal breeding. The goal is the creation of an analysis pipeline for genomic selection. This comprises tools
  for genotypic, phenotypic and pedigree data. The steps of a typical analysis are presented in this document. This starts with the coding of the marker data, followed by the construction of relationship matrices according
  to pedigree or genomic relationship matrices based on marker data, i.e. according to \citet{vanRaden2008}. At the end the use of linear mixed models for genomic selection are descriped. \\

  \noindent{\bf Keywords:} synergistic plant and animal breeding, kinship, pedigree, genomic marker data, mixed models, genomic selection
  

  
\end{abstract}


\section{Introduction}\label{sec:Introduction}

The R-package 'synbreed' aims to provide the tools that are necassary to analyze data of breeding programs and perform genomic selecton. Of course, allready
a huge number of software exists for this purpose. The idea of this package is to collect the methods in one package, so that analysis can be performed in one software with just a few steps as descriped in this document. 
Additional, this package takes care of special problems of modern breeding programms as the use of doupled haploid (DH) lines in plant breeding.  Most of packages source code is written in R, so that methods could 
easily be adopted for special purposes.

In this document, the term \textit{genotype} refers to an individuals set of genomic attributes and thus is synonym for an individual. The \textit{phenotype} denotes the observed value of an genotype, i.e. a trait
of commercial interst in breeding programms. The term \textit{genomic markers} refers to a \textit{locus} on the genome where the individuals alleles are measured. At the moment,
the package deals only with two different alleles for each locus which hold if biallelic SNP (single nucleotid polymorphism) markers are used.

The idea of \textit{genomic selection} is that some of the markers are linked to a \textit{quantitative trait loci} (QTL) with an effect on a quantitative phenotypic values. \citet{Meuwissen2001} proposed to make
use of the markers an regress the phenotype on the genotype. The esimated could be used to select the genotypes which a favourable set of genes and select the for the next breeding scheme.

The remainder of this document is structured as follows. In section \ref{sec:ExampleData} a simulated data set is presented which is used to illustrate the methods throughout the document. Section \ref{sec:MarkerData} describes the formatting of marker data  and section \ref{sec:Pedigree} shows how to utilize pedigree information. Section \ref{sec:LinkageDisequilibrium} shows how Linkage Disequilibrium between markers could be expoited using \texttt{synbreed} package. In section \ref{sec:RelationshipMatrices} several methods to set up relationship matrices are presented. 



\section{Example data}\label{sec:ExampleData}

In this document the steps of an analysis pipline for genotypic and phenotypic data in plant or animal breeding with the R-package 'synbreed' are presented. For illustration, a simulated data set for maize called \texttt{maize}, which is part of the package, is used. 
To load \texttt{maize} data, use
<<results=hide>>=
library(synbreed)
data(maize)
@
This data set contains genotypic and phenotypic data, as well as pedigree information up to grand parents for \Sexpr{ nrow(maize.pheno)} maize lines. When loading \texttt{maize} data, in fact the following
four data sets are loaded into workspace
\begin{description}
\item[maize.geno]  This is a \texttt{data.frame} containing the marker data of \Sexpr{ ncol(maize.geno)-1} biallelic SNP-markers for the \Sexpr{ nrow(maize.pheno)} genotypes. 
The first column of the data set contains the \texttt{ID} for the identification of the genotypes.
This variable should be used for the merge with the phenotypic data. 
The marker data is coded with 0/1 and because of simulated data no missing values are present. 
Note that the coding does not contain any information about allel frequencies, thus 1 could be minor or major allele.
\item[maize.pheno] This is a \texttt{data.frame} has one column \texttt{ID} and a column \texttt{Trait} containing the measured phenotypic trait. The order of the genotypes is the same as the order of rows in \texttt{maize.geno}.
\item[maize.ped] This  \texttt{data.frame} contains the pedigree information of  1301 genotypes (1250 lines and 51 ancestors). 
\item[maize.marker.pos]  This  \texttt{data.frame} contains additional information for the SNP markers. The first column \texttt{pos} gives the position of the marker on the chromosome in cM. The second column \texttt{chr} sepecifies the chromosome (linkage group) the marker belongs to. The order of the markers is the same as the order of columns in \texttt{maize.geno}.
\end{description}

\section{Marker data}\label{sec:MarkerData}

In the first step, marker data has to be coded in a way that it could be used for the construction of genomic relationship matrices. For biallelic marker data, the minor allele should be coded as 2 and the major allele as 0.
This task is done by the function \texttt{codeGeno}. If no missing values and heterozygous genotypes are present 
and all markers should be used in the following analyses, this function does simply recode the alleles as mentioned above.
For the \texttt{maize} data, use
<<>>=
marker <- codeGeno(maize.geno[,-1])
@
to obtain a object \texttt{marker} which contains the recoded marker data. 
Note that the first column is not used because it contains the \texttt{ID}. 
Now, the minor allele frequencies are easily obtained by dividing the column means of \texttt{marker} by 2. 
A histogramm of the minor allele frequencies is shown in Figure \ref{fig:histmaf}.

\begin{figure}[h]
\centering
<<fig=TRUE,echo=FALSE,results=hide,width=12,height=8>>=
hist(colMeans(marker)/2,xlab="minor allele frequency",main="",nclass=20)
@
\caption{Histogramm of the minor allele frequency of the \Sexpr{ ncol(maize.geno)-1} SNP markers in \texttt{maize} data.}
\label{fig:histmaf}
\end{figure}

In experimental data usually missing values occour in genotypic data due to different reasons 
(i.e. heterozygous genotypes for one locus in homozygous lines).  
The function \texttt{codeGeno} provides the possibility to impute missing values by chance or according to family structure using the following rules:
\begin{description}
\item[with population structure]
Suppose an observation $i$ is missing (NA) for a marker $j$ in population $k$. If marker $j$ is fixed in population $k$, 
the imputed value will be the fixed allele. If marker $j$ is segregating in population $k$, 
the value is 0 with probability 0.5 and 2 with probability 0.5.
\item[without population structure] The missing values for a marker $j$ are sampled from the allele distribution of marker $j$.
\end{description}           
To illustrate the difference in classification of missing values, 200 entries of the marker matrix are selected, the values saved and these entries are coded as \texttt{NA}. 
<<>>=
marker <- as.matrix(marker)
ind1 <- sample(1:nrow(marker),200)                                            
ind2 <- sample(1:ncol(marker),200)
posNA <- cbind(ind1,ind2)
original <- marker[posNA]
marker[posNA] <- NA
@                                                                                                                                                                                            
The number of  \Sexpr{ nrow(maize.pheno)} genotypes in the \texttt{maize} data consist of 25 \textit{half sib} families with 50 genotypes in each family. The genotypes are ordered according to the family structure. 
<<>>=
pop <- rep(1:25,each=50)
@
Recoding of the marker data and imputing of the missing  values is done as follows
<<>>=
marker1 <- codeGeno(marker,impute=TRUE,pop)
@                                                                                                                                              
A report is printed on the screen which informs about the number of imputations performed according to family structure $n_F$ or chance $n_R$. The approximative fraction of correct imputations is $\frac{n_F + 0.5n_R}{n_F+n_R}$. For the simulated data the 
original values are known. With the following commands the quality of the classification of the missing values is judged: 
<<>>=
# compare in crosstable
imputed <- marker1[posNA]
(t1 <- table(original,imputed))
@
The fraction of correct replacements is
<<>>=
sum(diag(t1))/sum(t1)
@      
Note that expected fraction of correct imputation without family structure equals 0.5.

In an analysis of genotypic data it is common to discard marker with a small minor allele frequency and/or many missing values. 
There are two additional arguments \texttt{maf} and \texttt{nmiss} for function \texttt{codeGeno}. 
Before recoding the data all marker with more than
\texttt{nmiss}$\cdot 100\%$ missing values are discarded. 
After recoding the maker data only markers with a minor allele frequency $>$ \texttt{maf} are returned by the function. 
By default, no markers are selected by one of both criteria, thus \texttt{maf}=\texttt{nmiss}=0.
                                       
%To summarize, the steps presented in Algorithm \ref{alg:codeGeno} are performed.

%\begin{algorithm}[H]
%\SetAlgoLined
%\KwData{\texttt{data.frame} or \texttt{matrix} with $M$ biallelic marker data coded arbitrarily and missing data for $n$ genotypes $g_{ij}$.}
%\KwResult{Marker data without missing vaules with minor allele coded as 2 and major allele coded as 0.}
%\For{$j=$1 to $M$ }{
%\lIf{\% missings $>$ nmiss$\cdot 100\%$} discard marker $j$\;
%\lElse{}{
%Create frequency table for allele $A_1$ and $A_2$ for marker $j$\;
%Order alleles decreasingby their frequencies $f(A_{(1)}) > f(A_{(2)})$\;
%}
%\For{$i=1$ to $n$}{
%\lIf{$g_{ij}$ = $A_{(1)}$}{
%$g_{ij}$ = 0\;
%}
%\lIf{$g_{ij}$ = $A_{(2)}$}{
%$g_{ij}$ = 2\;
%}
%\lElse{}{
%\lIf{$\bs{g}_i$ is segregating in family of genotype $i$}{
%$g_{ij} = \left\{ \begin{array}{ll} 0 & p=0.5 \\ 2 & p=0.5 \end{array} \right. $\;
%}
%\lElse{}{
%$g_{ij}$ = fixed allele in family of genotype $i$\;
%}}
%}
%}
%Recode alleles if minor allele changed due to imputing of missing values\;
%Reject markers with minor allele frequency $<$ \texttt{maf}\;
%\caption{Umkodieren der Allele und Ersetzen von fehlenden Werten}
%\label{alg:codeGeno}
%\end{algorithm}     

Note that missing values in the marker data must be coded as \texttt{NA}. Instead of imputing the values \texttt{codeGeno} provides the possibility to replace the missing values by a certain value, i.e. 1 which is the expection for the missing values. Different codings of the alleles could easily be obtained with simple operations of the resulting data.

\section{Linkage Disequilibrium}\label{sec:LinkageDisequilibrium}

\textit{Linkage Disequilibrium} (LD) is defined as a non-random association between polymorphisms at two or more loci. 
It is calculated as the difference between observed and expected (assuming random distributions) allelic frequencies. There are many possibilities to compute LD from genotypic data. In \texttt{synbreed} package, LD between two loci $i$ and $j$ denoted as $LD_{ij}$
is computed as coefficient of determination $R^2$ between the data of the genotypes $\bf x_i$ and $\bf x_j$ at both loci. $\bf x_i$ is an $n$-dimensional vector containing marker data of $n$ individuals. This equals squared correlation coefficient of both data vectors, thus
$$  LD_{ij} = r(\bf x_i,\bf x_j)^2 .$$
Usually the the overall amount of LD of markers inbetween each linkage groups is of interest as well as the decline of LD when physical distance of markers on chromosome is increasing. To plot the distance versus the LD for each linkage group, use function \texttt{LDDist}, to make a LD Heatmap for values of $R^2$, use function \texttt{LDMap}.
For \texttt{maize} we plot the LD for the first chromosome

\begin{figure}[!h]
<<fig=TRUE>>=
data(maize)
marker <- codeGeno(maize.geno[,-1])
chr1 <- maize.marker.pos$chr == 1 
LDDist(marker[,chr1],maize.marker.pos$chr[chr1],maize.marker.pos$pos[chr1])
@ 
\caption{LD versus distance plot for first chromosome of \texttt{maize} data.}
\label{fig:LDDist}
\end{figure}

LD heatmap for pairwise LD of markers on the first chromosome is obtained as 
\begin{figure}[!h]
<<fig=TRUE>>=
LDMap(marker[,chr1],maize.marker.pos$chr[chr1],maize.marker.pos$pos[chr1])
@ 
\caption{LD heatmap for markers on first chromosome of \texttt{maize} data.}
\label{fig:LDDist}
\end{figure} 



\section{Pedigree}\label{sec:Pedigree}     
                               
An important source of information in breeding programs is pedigree information. Especially in animal breeding, pedigree is recorded over many generations. The pedigree usually consists 
of a list of individuals (animals or plants) of the current generation which is the subject of analysis and their ancestors (for which usually no phenotypic data is available). The pedigree is sorted the generation, beginning with the individuals with unknown parents. An example for an pedigree with five individuals belonging to 4 generations is given below.

\begin{table}[!h]
\centering
\begin{tabular}{cccc}
\hline
ID & Par1 & Par2 & gener \\
\hline
A & - & - & 0 \\
B & - & - & 0 \\
C & A & B & 1 \\
D & A & C & 2 \\
E & D & B & 3 \\
\hline
\end{tabular}
\end{table}

Note that unknown parents are coded as "0" in \texttt{synbreed} package and generation starts with 0. In \texttt{synbreed} exists the class "pedigree", which 
should be used for handling pedigree information. An object of class "pedigree" consists of a \texttt{data.frame} with at least variables \texttt{ID}, \texttt{Par1}, \texttt{Par2} and \texttt{gener}.
The function \texttt{create.pedigree} creates an object of class  "pedigree" for a given set of individuals and the pair of parents. The generation can be specified by the user or optional computed by the function.

Suppose we have the pedigree struture of the example. This structure is carried into \texttt{synbreed} package with the following command:
<<>>=
id <- c("A","B","C","D","E")
par1 <- c(0,0,"A","A","D")
par2 <- c(0,0,"B","C","B") 
ped <- create.pedigree(id,par1,par2)
ped
@  
An object of class "pedigree" could be visualised with generic plotting function for S3 class "pedigree".
 
\begin{figure}[!h] 
<<fig=TRUE>>=
plot(ped)
@   
\end{figure}    
      
It is possible to simulate a pedigree structure with function \texttt{simul.pedigree}. As arguments,
the number of generations to simulate and the number of individuals in each generation has to be specified. By default, random mating 
is assumed in each generation. As their are no further restrictions, it is possible that inbreeds could be generated when parent 1 equals parent 2.
To simulate a pedigree with 6 generations and 4, 6, 7, 9, 10 and 10 individuals in each generation, use
<<>>=
set.seed(123)
ped.simul <- simul.pedigree(gener=6,ids=c(4, 6, 7, 9, 10,10))
@ 
The resulting pedigree is visualized in Figure \ref{fig:simupedi}.
\begin{figure}[!h]
<<fig=TRUE>>=
plot(ped.simul)
@
\caption{Simulated pedigree structure}
\label{fig:simupedi}
\end{figure}

  

\section{Relationship matrices}\label{sec:RelationshipMatrices}  

Pedigree information is usually used to set up relationship matrices for a set of individuals. The relationship is constructed by the \textit{expected} fraction of alleles that are identical by descent (IBD) between relatives. Another possibility to set up a relationship is the use of marker data to compute the genomic relationship. This gives the \textit{observed} relationship of individuals.

\subsection{Based on Pedigree}

The computation of the pedigree based relationship in \texttt{synbreed} starts with the gametic relationship. A gamet is the genetic unit that an individual passes to its offspring. The genetic value of an individual at one locus consists of two allelels. 
Suppose there is an individual C with the parents A and B. Individual C has to alleles C1 and C2. The source of allele C1 is Parent A, thus allele C1 could either be IBD to A1 or A2. Allele C2 was inherited of parent B, thus it could be IBD to B1 or B2. 
To compute the gametic relationship start with an expanded table with two alleles for each individual. 
 
\begin{table}[!h]
\centering
\begin{tabular}{cccc}
\hline
ID & Allele & Par1 & Par2 \\
\hline
A & A1 & - & - \\
A & A2 & - & - \\
B & B1 & - & - \\
B & B1 & - & - \\
C & C1 & A1 & A2 \\
C & C2 & B1 & B2 \\
D & D1 & A1 & A2 \\
D & D2 & C1 & C2 \\
E & E1 & D1 & D2 \\
E & E2 & B1 & B2 \\
\hline
\end{tabular}
\end{table}

This table is converted into the gametic relationship $\bf G$ matrix which is of order $2n$, if the number of individuals is $n$. The diagonal values of $\bf G$ are always 1. The off-diagonal values give the probabilty that two alleles $A_1$ and $A_2$ are identical by
descent (IBD), denoted as $P(A_1 \equiv A_2)$. If the parents are unknown, it is assumed that they are progeny of a random mating population. In this case the off-diagonals are zero. The gametic relationsship matrix is constructed recursively, starting with the first 
generation in pedigree. 
The combination of $2^2=4$ alleles that describe the relationship of progeny A with parent C are computed as follows
\begin{eqnarray*} 
P(A_1 \equiv C_1) &=& 0.5 \cdot \left[P(A_1 \equiv A_1) + P(A_1 \equiv A_2)\right]  \\
P(A_1 \equiv C_2) &=& 0.5 \cdot \left[P(A_1 \equiv B_1) + P(A_1 \equiv B_2)\right]  \\
P(A_2 \equiv C_1) &=& 0.5 \cdot \left[P(A_2 \equiv A_1) + P(A_2 \equiv A_2)\right]  \\
P(A_2 \equiv C_2) &=& 0.5 \cdot \left[P(A_2 \equiv B_1) + P(A_2 \equiv B_2)\right]   
\end{eqnarray*}
The gametic relationship for a given pedigree is obtained as follows
<<>>=
G <- kinship(ped,ret="gam")
G
@
The resulting object \texttt{G} is of class "relationshipMatrix" which is the general class for all kinds of relationship matrices (gametic relationship, additive and dominance relationship, kinship). An object of class "relationshipMatrix" is basically a symmetric matrix containing the relationship coefficient of two individuals.
Note that the entry in \texttt{G} of allele $x_1$ and allele $x_2$ of an individual $X$ equals his inbreeding coefficient $$F_X=P(x_1 \equiv x_2).$$ For example, the inbreeding coefficent of individual D is
<<>>=
as.numeric(G["D_1","D_2"]) 
@
which is nonzero because individuals A and C, which are the parents of D, are relatives. Once the gametic relationship is computed, it could be converted in the additive numerator relationship matrix $\bf A$ or the dominance relationship matrix $\bf D$.
 The additive relationship between tindividuals $X$ and $Y$ is given by
$$ A_{XY} = \begin{cases} 1+F_X, & X=Y \\ 2f_{XY}, & X\neq Y \end{cases}$$
where $f_{XY}$ is the \textit{coefficient of coancestry} \citep{Wright1922} which is defined as
\begin{equation}
f_{XY} = P(X \equiv Y) = \frac{1}{4}\left[ P(x_1 \equiv y_1) + P(x_1 \equiv y_2) + P(x_2 \equiv y_1) + P(x_2 \equiv y_2)\right].
\end{equation} 
The additive numerator relationship matrix descripes the additive relationship between individuals and is of order $n$. 
It is typically used in the animal model to estimate breeding values (additive genetic effects), see Section \ref{sec:Models}
 The additive numerator relationship matrix for a given pedigree is obtained as follows
<<>>=
A <- kinship(ped,ret="add")
A
@
Note that the diagonals of $\bf A$ are $1+F_i$ for $i=1,...,n$. Sometimes the kinship matrix is required, which is half of the additive numerator relationship matrix. It is obtained by
<<>>=
K <- kinship(ped,ret="kin")
@

Additionally it is possible to derive the dominance relationship matrix $\bf D$ out of $\bf G$. The dominance is needed in the non-additive animal model. The dominance relationship between individuals $X$ and $Y$ is given by
is defined as \citep{Oakey2006}  
$$ D_{XY} = \begin{cases} 1-F_X, & X=Y \\ t_{XY}, & X\neq Y \end{cases}$$
with $t_{XY}$ being the coefficient of dominance coaviance which is defined as
\begin{eqnarray*}
t_{XY} &=& P(x_1 \equiv y_1 \neq x_2 \equiv y_2) +  P(x_1 \equiv y_2 \neq x_2 \equiv y_1) \\
&=&  P(x_1 \neq x_2)P(y_1 \neq y_2)\left[ P(x_1 \equiv y_1)P(x_2 \equiv y_2)+P(x_2 \equiv y_1)P(x_1 \equiv y_2) \right] \\
&=& (1-F_X)(1-F_Y)\left[ P(x_1 \equiv y_1)P(x_2 \equiv y_2)+P(x_2 \equiv y_1)P(x_1 \equiv y_2) \right].
\end{eqnarray*}
Note that for a completely homozygous line $X$ dominance is zero because $F_X=1$. Dominance relationship matrix 
for the example pedigree is obtained  by
<<>>=
D <- kinship(ped,ret="dom")
D
@
Variance-covariance matrices for effects of heigher order interactions in the non-additive animal model as additive-additive (AA), additive-dominance (AD) or dominance-dominance (DD) variance-covariance matrices can be computes as
<<>>= 
(AA <- A*A)
(AD <- A*D)
(DD <- D*D)
@                                        
Model \eqref{eq:nonaddmodel} can be extended by these effects, but the contribution of three-way or higher interactions is usually small.  


\subsection{Based on marker data}

                 

The relationship matrix based on marker data or genomic relationship matrix data represents the true relationship between relatives
more precise than the numerator relationship based on pedigree, as it takes into account that relationship may deviate from the expected average relationship due to
Mendelian sampling effect.  Two methods for the construction of a relationship matrix based on marker data are implemented in the \texttt{synbreed} package: genomic relationship according to vanRaden \citep{vanRaden2008} and according to Roger's distance  \citep{Rogers1972}. 

For vanRaden, the SNP genotypes are coded as the number of copies of one of the SNP alleles, i.e., 0, 1 or 2 (any linear transformations of these values are valid too). Thus the marker data could be the result of a call of \texttt{codeGeno} when imputing for the missing values was performed or the missing values were replaced with the value 1.
The genomic relationship matrix according to vanRaden is computed as
\begin{equation}
\frac{\bf{Z}\bf{Z}'}{2\sum_{i=1}^p p_i(1-p_i)},
\end{equation}
where $\bf{Z}=\bf{M}-\bf{P}$ and $\bf{M}$ is the marker matrix and $\bf{P}$ contains the allele frequencies multiplied by 2. $p_i$ is the allele frequency of marker $i$.  As an example we look at the marker data of 6 individuals genotyped with 8 SNP markers. Let
$$ \bf M = \begin{pmatrix}  2 & 0 & 0 & 2 & 2 & 0 & 0 & 0 \\ 
   2 & 0 & 2 & 2 & 2 & 0 & 2 & 2 \\ 
   2 & 0 & 2 & 2 & 0 & 0 & 2 & 0 \\ 
   0 & 0 & 2 & 2 & 0 & 0 & 2 & 0 \\ 
   0 & 0 & 2 & 0 & 0 & 0 & 2 & 0 \\ 
   2 & 2 & 2 & 2 & 0 & 0 & 0 & 2 \\  
   \end{pmatrix}, $$
then it holds that
$$ \bf P = \begin{pmatrix}  1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\ 
   1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\ 
   1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\  
   1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\ 
   1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\  
   1.33 & 0.33 & 1.67 & 1.67  & 0.67 & 0 &  1.33&  0.67 \\   
   \end{pmatrix} $$
 $$    \bf Z = \begin{pmatrix}   0.67 & -0.33 & -1.67 & 0.33 & 1.33 & 0.00 & -1.33 & -0.67 \\ 
  0.67 & -0.33 & 0.33 & 0.33 & 1.33 & 0.00 & 0.67 & 1.33 \\ 
   0.67 & -0.33 & 0.33 & 0.33 & -0.67 & 0.00 & 0.67 & -0.67 \\ 
  -1.33 & -0.33 & 0.33 & 0.33 & -0.67 & 0.00 & 0.67 & -0.67 \\ 
   -1.33 & -0.33 & 0.33 & -1.67 & -0.67 & 0.00 & 0.67 & -0.67 \\ 
   0.67 & 1.67 & 0.33 & 0.33 & -0.67 & 0.00 & -1.33 & 1.33 \\ 
   \end{pmatrix}
  $$  
  and 
  $$ \bf Z \bf Z ' = \begin{pmatrix}  
   7.44 & 0.11 & -1.22 & -2.56 & -3.22 & -0.56 \\ 
   0.11 & 4.78 & -0.56 & -1.89 & -2.56 & 0.11 \\ 
   -1.22 & -0.56 & 2.11 & 0.78 & 0.11 & -1.22 \\ 
   -2.56 & -1.89 & 0.78 & 3.44 & 2.78 & -2.56 \\ 
   -3.22 & -2.56 & 0.11 & 2.78 & 6.11 & -3.22 \\ 
   -0.56 & 0.11 & -1.22 & -2.56 & -3.22 & 7.44 \\
     \end{pmatrix}
  $$  
with the denominator being $2\sum_{i=1}^p p_i(1-p_i)=2.611$. To compute the genomic relationship according to vanRaden, matrix $\bf M$ is passed to the funtion \texttt{vanRaden}  
<<>>=
M <- matrix(data=c(2,0,0,2,2,0,0,0,
                   2,0,2,2,2,0,2,2,
                   2,0,2,2,0,0,2,0,
                   0,0,2,2,0,0,2,0,
                   0,0,2,0,0,0,2,0,
                   2,2,2,2,0,0,0,2),
                   nrow=6,byrow=TRUE)
vR <- vanRaden(M) 
round(vR,3)                  
@
Note the object \texttt{vR} is again of class "relationshipMatrix".    

Another possibility is to compute the genomic relationship matrix according to Roger's distance. Roger's distance is computed as 
\begin{equation}
d=\frac{1}{p}\sum_{i=1}^p \sqrt{1/2 \sum_{j=1}^{n_i}(p_{ij}-q_{ij})^2}
\end{equation}
where $p$ is the number of markers and $n_i$ is the number of alleles for marker $i$. Let $p_{ij}$ and $q_{ij}$ denote the allele frequencies of allele $j$ for marker $i$ respectively. Note that marker data should be coded $-1$ and $1$ for homozygous genotypes and 0 for heterozygous. If marker data is code 0/1/2 data is transformed automatically
when funtion \texttt{rogers} is used, which computes Roger's distance.  



\subsection{Doubled haploid lines}

In plant breeding doubled haploid (DH) lines are common. DH lines are fully inbreed and thus have an inbreeding coefficient of 1. This has to be taken into account, when the relationship matrix in a pedigree with DH lines is computed.  As an example the \texttt{maize} data is taken.
<<>>=
data(maize)
head(maize.ped)
@
First, the additive numerator relationship matrix is computed. There are \Sexpr{table(maize.ped$DH)[2]} DH lines and \Sexpr{table(maize.ped$DH)[1]} non DH lines in the pedigree. For DH lines special treatment is necassary, as the inbreeding coefficient must be 1. An argument \texttt{DH} is available for function \texttt{kinship} where
for each individual in the pedigree it specified whether this is a DH line or not. This information is available for the \texttt{maize} data. To obtain the addtive numerator relationship matrix, use 
<<>>=
ped.maize <- create.pedigree(maize.ped$ID,maize.ped$Par1,maize.ped$Par2)
A.maize <- kinship(ped.maize,DH=maize.ped$DH,ret="add")
dim(A.maize) 
@

\subsection{Visualisation of relationship matrices}

As in most cases a relationship matrix is to big to print it on the screen. Thus there are two possibilites for visualisation of an object of class "relationshipMatrix" in \texttt{synbreed} package. A \texttt{summary} method is defined which gives the important characteristics of a relationship matrix. Use
<<>>=
summary(A.maize)
@
to get the summary for the pedigree based additive relationship matrix of the \texttt{maize} data. Another possibility is the \texttt{plot} method which could be applied
to an object of class "relationshipMatrix". This gives a heatmap of the entries of the relationship matrix
%\begin{figure}
%<<fig=TRUE>>=
%plot(A.maize100)
%@
%\caption{Heatmap of pedigree based additive relationship matrix for \texttt{maize} data.}
%\label{fig:heatpedi}
%\end{figure}
%In Figure \ref{fig:heatpedi} one can see the family  structure in the data which is consiting of 25 families.

Note that objects of class "relationshipMatrix" can be writen two input files appropriate for Mixed Model software as \texttt{WOMBAT} \citep{Meyer2006} or \texttt{ASReml} \citep{Gilmour2000}.

\section{Models}\label{sec:Models}

The ultimate aim in the analysis of a breeding programm is the estimation of breeding values (additive genetic effects). The basic statistical model for this purpose is a linear mixed model
\begin{equation}\label{eq:mm}
\bf y = \bf X \bf b + \bf Z \bf u + \bf e,
\end{equation}
where $\bf y$ is the $n \times 1$ vector of phenotypic records, $\bf b$ a $t \times 1$ vector of fixed effects and $\bf u$ a  $m \times 1$ vector of random effects. $\bf X$ and $\bf Z$ are the corresponding design matrices with dimension $n \times t$  and $n \times m$ respectively. For the random effect, it is assumend that
$$ \bf u \sim \text{N}( \bf 0, \bf G \sigma^2_g)$$
where $\bf G$ is a variance-covariance matrix. $\bf e$ denotes the $n \times 1$ vector of residuals with $ \bf e \sim \text{N}( \bf 0, \bf I_n \sigma^2)$ and $\bf I_n$ is the $n$-dimensional identity matrix.
                                                                                                                                                    
If $\bf G$ equals the additive numerator relationship matrix $\bf A$, model \eqref{eq:mm} is called \textit{animal model}. Here the random effect is usually denote as $\bf a$ and $ \bf a \sim \text{N}( \bf 0, \bf A \sigma^2_a)$.  This model is used to estimate breeding values based on phenotypic records and pedigree information. As an example we will consider simulate plant breeding data. A pedigree with 5 generations and 20 individuals in each generation. Phenotypic data was measured in a field trial consiting of 5 locations with two replications (blocks) within locations for each of the $n=100$ genotypes.

The simulation of phenotypes is done with the function \texttt{simul.phenotpe} which simulates records based on model \eqref{eq:mm} with an overall mean as fixed effects and random effects for genotype, location and block. Random effects for location and block nested in location are i.i.d. normal. Random effect for genotype is simulated according to multivariate normal distribution $\text{N}( \bf 0, \bf A \sigma^2_a)$, where $\bf A$ is the numerator relationship matrix obtained be pedigree information. $\sigma^2_a$ and variance components for the other effects are specified by the user. Simulated data is obtained as follows
<<>>=                                      
ped <- simul.pedigree(5,20)
vc <-  list(sigma2e=15,sigma2a=10,sigma2l=0,sigma2b=0)
dat <- simul.phenotype(ped,Nloc=5,Nrepl=2,vc=vc)
str(dat)
@
Variance components for location and block are zero as only additive genetic effects should be considered in this example. The simulated random effects for 
genotype are called true breeding values (TBV).

Estimation of variance components with REML and prediction of random effects in model \eqref{eq:mm} could be done with the R package \texttt{regress}. This package allows for arbitrary variance-covariance matrizes of random effects. Solutions for animal model with overall mean as fixed effect is obtained as 
<<>>=
library(regress)
A <- kinship(ped,ret="add")
A <- A %x% matrix(1,10,10)
mod <- regress(Trait ~ 1, Vformula=~A,data=dat)
summary(mod)           
@
Note that variance-covariance matrix must be of same dimenson as $y$. This could easily be obtained by using the Kronecker product as data is sorted by individuals. As the fitted model only contains one random effect, estimated breeding values are 
<<>>=
ebv <- mod$predicted - mod$fitted
@
as \texttt{predicted} equals $\bf \hat y$ and \texttt{fitted} contains estimated overall mean. Correlation between observed and estimated phenotypes (also called \textit{predictive ability} of the model, see \citet{Legarra2008}) is
<<>>=
cor(ebv,dat$Trait)
@  
and correlation between estimated and true genetic effect (called \textit{accuracy} of the model) is
<<>>=
cor(ebv,dat$TBV)
@

At the end of one cycle of a breeding sheme the individuals with highest breeding values are selected for the next breeding cycle. The term \textit{genomic selection} refers to the situation where genotypic data is used to estimate genetic effects of the individuals. This is the case if a genomic relationship matrix is used as varianance-covariance matrix in the animal model. In \texttt{maize} data genotypic data is available for all phenotyped individuals. This is used to set up genomic relationship according to vanRanden  and passed to \texttt{regress}
<<>>=
data(maize)
marker <- codeGeno(maize.geno[, -1])
vR <- vanRaden(marker)    
y <- maize.pheno$Trait
mod.maize <- regress(y~1,Vformula=~vR)
summary(mod.maize)
@
Note that we have only one phenotypic record for each genotype Predictive ability of this model is
<<>>=                                                  
yhat <- mod.maize$predicted
cor(yhat,y)
@
Genomic selection is done by choosing the, e.g. 20\% genotypes with highest values for $\bf \hat y $.


 
                                                                                                                                                      

 


\section{Acknowledgements}

This research was funded by the German Federal Ministry of Education and                                                                                    
Research (BMBF) within the AgroClustEr \textit{Synbreed} $-$  \textit{Synergistic plant and
animal breeding}.

  \bibliography{references}

\end{document}                                                                                                                                                       